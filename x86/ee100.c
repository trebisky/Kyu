/*
 * Copyright (C) 2016  Tom Trebisky  <tom@mmto.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. See README and COPYING for
 * more details.
 */
/* ee100.c
 * Driver for the Intel Pro/100 ethernet adapter.
 * the first working network driver for skidoo.
 * 
 * Intel (bless their hearts) has published a 173 page
 *  manual (dubbed the OSSDM):
 * Open Source Software Developer Manual (January, 2003)
 * for the Intel 8255x 10/100 Mbps Ethernet Controller Family
 * that has been invaluable in developing this driver.
 *
 * Also the etherboot eepro100.c driver provided a concise
 * bit of working code that helped get this off the ground.
 * Ultimately even the etherboot code owes a debt to
 * the linux driver by Donald Becker.
 *
 * My card is a Intel Pro/100 S with an 82550PM chip
 * but should work (or be able to be make to work)
 * with the entire 8255x family.
 * I have also tried it with a i82558B
 * (and I have a i82559 Ether Pro 100+ that I
 *  will try this with someday)
 *
 * Tom Trebisky  tom@mmto.org  Skidoo project
 *	3-09-2005 began coding, read eeprom.
 *	3-19-2005 first began receiving packets.
 *	3-20-2005 first sent packets.
 *
 * The card I am working with at home is a i82558B based card
 * with ether address: 00:50:8B:0D:B0:EB (Compaq:0D:B0:EB)
 */

#include "intel.h"
#include "pci.h"
#include "net.h"
#include "netbuf.h"

#ifdef VXWORKS
#include "vxWorks.h"
#include "iv.h"
#endif

typedef void (*pcifptr) ( struct pci_dev * );

#define EE_VENDOR	0x8086
#define EE_DEVICE	0x1229

#define EEPROM_SIZE	16

struct ee_info {
	void *memaddr;
	void *ioaddr;
	void *iobase;
	int count;
	int irq;
	unsigned short eeprom[EEPROM_SIZE];
	unsigned char eaddr[ETH_ADDR_SIZE];
	int active;
};

static struct ee_info ee_soft;

/* Prototypes */
void ee_start_rcv ( int );
void ee_xmt_done ( void );

void
ee_activate ( void )
{
	ee_soft.active = 1;
}

void
get_ee_addr ( unsigned char *buf )
{
    	memcpy ( buf, ee_soft.eaddr, ETH_ADDR_SIZE );
}

/* Here is a short "tutorial" on the Intel Pro/100
 * The card has two independent internal processors.
 * the RU (receive unit) and the CU (command unit).
 * the CU is responsible for transmitting packets.
 * This is actually reasonable design, not the nightmare
 * the original intel ethernet chip (the 82586) was,
 * although it models many of that chips datastructures.
 *
 * Cleaning up the segmented addressing was a major step
 * into the 20th century, we set the base register for
 * the CU and RU to zero, and just use 32 bit offsets as
 * linear addresses and smile all the way to the bank.
 *
 * The major components of the card are:
 *	the RU and CU
 *	the eeprom with the station address.
 *	the media interface unit.
 *	flash memory (to support boot firmware).
 *
 * This driver ignores power management and wake on LAN.
 *
 * The chip is controlled by a set of on-chip registers
 *  (the CSR), and a pair of off-chip datastructures:
 *  the CBL (command block list ... for the CU) and
 *  the RFA (receive frame area ... for the RU).
 * The first 8 bytes (2 registers) of the CSR is dubbed
 *  the SCB (system control block) and consists of the
 *  status and command registers.
 *
 * The CBL is simple, it is just a list of Command Blocks (CBs).
 * The RFA is more complex; it consists of a list of
 *  RFD's (Receive Frame Descriptors), each of which points
 *  to a buffer descriptor each of which can point to a list
 *  of buffers (for "scatter" reception).
 *
 * "The man who sets out to carry a cat by its tail learns
 *  something that will always be useful and which never will
 *  grow dim or doubtful"  --  Mark Twain
 */

/* This is the layout of registers on chip
 */
#define CSR_STATUS	0x00
#define CSR_CMD		0x02
#define CSR_PTR		0x04
#define CSR_PORT	0x08
#define CSR_FLASH	0x0c
#define CSR_EEPROM	0x0e
#define CSR_MDI		0x10
#define CSR_DMA		0x14

/* Here is junk we can cram into the CSR_CMD register.
 * The low 3 bits (the 4th is unused) controls the RU.
 * The next 4 control the CU.
 * The next 2 are special interrupt stuf
 * The upper 6 are specific interrupt masks for
 * individual sources in the chip (not present in the 82557).
 */
#define CU_NOP		0x0000
#define CU_START	0x0010
#define CU_RESUME	0x0020	/* nu */
#define CU_STATSADDR	0x0040
#define CU_DUMP		0x0050	/* Dump statistics */
#define CU_BASE		0x0060
#define CU_DUMPR	0x0070	/* Dump and reset */
#define CU_RESUMES	0x00A0	/* static resume */

#define RU_NOP		0x0000
#define RU_START	0x0001
#define RU_RESUME	0x0002	/* nu */
#define RU_DMAR		0x0003	/* DMA redirect */
#define RU_ABORT	0x0004	/* nu */
#define RU_HDS		0x0005	/* load header data size */
#define RU_BASE		0x0006

#define	INT_MASK	0x0100	/* set to disable interrupts */
#define	SOFT_INT	0x0200	/* generated by driver (not used) */

/* individual interrupt masks (not in 82557).
 * TNO = transmit failed with error
 * ER = partial frame ER (82558 or 82559)
 */
#define INT_FCP		0x0400	/* flow control pause */
#define INT_ER		0x0800
#define INT_RNR		0x1000	/* RU not ready */ 
#define INT_CNA		0x2000	/* CU not active */
#define INT_FR		0x4000	/* RU finished a frame */
#define INT_CX		0x8000	/* aka TNO, CU finished cmd */

/* How about the CSR status register? 
 * upper byte is STAT/ACK area,
 * the lower byte is the SCB (CU/RU) status
 * The upper byte indicates interrupt sources,
 * which can be cleared by writing a 1 back to that bit.
 */

#define ST_CX		0x8000	/* CU finished w/ interrupt */
#define ST_FR		0x4000	/* RU finished a frame */
#define ST_CNA		0x2000	/* CU is not active */
#define ST_RNR		0x1000	/* RU is not ready */
#define ST_MDI		0x0800	/* MDI cycle complete */
#define ST_SWI		0x0400	/* Software interrupt */
#define ST_FCP		0x0100	/* Flow control pause, 82558 and later only */

#define ST_CU_IDLE	0x0000
#define ST_CU_SUSP	0x0040
#define ST_CU_LPQA	0x0080
#define ST_CU_HQPA	0x00C0

#define ST_RU_IDLE	0x0000
#define ST_RU_SUSP	0x0004
#define ST_RU_NORES	0x0008
#define ST_RU_RDY	0x0010

/* This is a memory structure to receive statistics.
 * They wrap around to zero without warning.
 */
struct ee_stats {
    	unsigned long	tx_good;		/* good frames sent */
    	unsigned long	tx_coll;		/* not sent due to collisions */
    	unsigned long	tx_late;		/* not sent due to late collisions */
    	unsigned long	tx_underruns;		/* not sent due to DMA underrun */
    	unsigned long	tx_lost_carrier;	/* frames sent even without carrier */
    	unsigned long	tx_deferred;		/* frames sent after collision delays */
    	unsigned long	tx_one_colls;		/* frames sent after only 1 collision */
    	unsigned long	tx_multi_colls;		/* frames sent after multiple collisions */
    	unsigned long	tx_total_colls;		/* total collisions encountered while xmit */
    	unsigned long	rx_good;		/* good frames received */
    	unsigned long	rx_crc;			/* frames discarded due to bad CRC */
    	unsigned long	rx_align;		/* frames misaligned and with bad CRC */
    	unsigned long	rx_resource;		/* good frames discarded due to no resources */
    	unsigned long	rx_overrun;		/* frames lost due to fifo overflow (overrun) */
    	unsigned long	rx_colls;		/* frames encountering collision on receive */
    	unsigned long	rx_runt;		/* short frame count */
	/* beyond here, 82558 and after only */
    	unsigned long	tx_fcp;			/* count of flow control frames sent */
    	unsigned long	rx_fcp;			/* count of flow control frames received */
    	unsigned long	rx_invfcp;		/* count of invalid flow control frames received */
	/* beyond here, 82559 and after only */
    	unsigned long	tx_tco;			/* count of TCO packets sent */
    	unsigned long	rx_tco;			/* count of TCO packets received */
	unsigned long 	extra;			/* need extra word that we set to zero before dump */
};

static struct ee_stats stats;

/* The RFA (Receive Frame Area, is a bunch of free RFD's
 * (receive frame descriptors).  In the simplified memory
 * model, the data buffer immediately follows the size field
 * and must be capable of holding maximum ethernet size packets.
 * See page 105 ... in OpenSDM.
 */

#define ETHER_SIZE	1518

/* Receive frame descriptor */
struct rfd {
	volatile unsigned short status;
	unsigned short command;
	unsigned long link;
	unsigned long buffer;
	unsigned short count;
	unsigned short size;
};

#ifdef notdef
/* static receive frame descriptor and buffer */
struct rfd_buffer {
	struct rfd rhdr;
	char packet[ETHER_SIZE];
};

static struct rfd_buffer rxfd;
#endif

static struct netbuf *rx_buf;

/* Here are some commands for the CU in the clist (tfd)
 * start or resume get the CU going.
 */

#define	CL_NOP		0
#define	CL_SETUP	1	/* setup unique device address */
#define	CL_CONFIG	2	/* load operating parameters */
#define	CL_MULTI	3	/* load multicast addresses */
#define	CL_TX		4	/* send a single frame, simple */
#define	CL_TXF		0xc	/* send a single frame, flex mode */
#define	CL_MICRO	5	/* load chip microcode */
#define	CL_DUMP		6	/* dump internal registers */
#define	CL_DIAG		7	/* run self test */

#define CL_IDLE		0x8000	/* go idle after completion */
#define CL_SUSPEND	0x4000	/* suspend after completion */
#define CL_INT		0x2000	/* interrupt after completion */

#define CS_STAT		0x8000	/* execution status (1=done) */
#define CS_OK		0x2000	/* 1 indicates no error */
#define CS_URUN		0x1000	/* TX encountered underrun */

/* A NOP block is just 8 byes (cmd,status,link)
 * other blocks typically have extra stuff.
 * SETUP will have 6 bytes of ether address..
 */

/* The following command block is special for the way this
 * driver handles the TX command.
 * Simplified memory structure expects the buffer to
 * immediately follow the command block.
 * The flexible structure allows an array of multiple
 * buffers to be used ("gather" mode).
 * In addition, the 82258 introduced a new extended format
 * for the TCB (activated through a configure bit).
 * We use the original format to make the driver more versatile.
 * Actually the count field below absorbs several other fields
 * and sets them to zero as a convenient side effect.
 */

struct tfd {
	volatile unsigned short status;
	unsigned short command;
	/* -- */
	unsigned long link;
	unsigned long buffer;
	long count;		/* set to 2 */
	unsigned long addr0;	/* for header */
	long size0;
	unsigned long addr1;	/* for data */
	long size1;
};

static struct tfd txfd;

struct config {
	volatile unsigned short status;
	unsigned short command;
	unsigned long link;
	unsigned char stuff[22];
};

/* ripped off from linux kernel driver and etherboot
 * There are many differences here between individual chips.
 * See the OSSDM pages 61 thru 88.
 */
static struct config config_cmd = {
	0,			/* status */
	CL_CONFIG,		/* command */
	(unsigned long) &txfd,	/* link to next block */

	{
	   22,			/* 0 - byte count (includes this byte) */
	   0x08,		/* 1 - fifo limits tx<<4 | rx */
	   0,			/* 2 - adaptive interframe spacing */
	   0,			/* 3 - 4 bits defined */
	   0,			/* 4 - receive DMA min byte count */
	   0x80,		/* 5 - transmit DMA max byte count */
	   0x32,		/* 6 - what to do with bad frames */
	   0x03,		/* 7 - more of the same */
	   1,			/* 8 - chip dependent */
	   0,			/* 9 - wake up and VLAN bits */
	   0x2e,		/* 10 - loopback, preamble length, NSAI */
	   0,			/* 11 - zeros */
	   0x61,		/* 12 - interframe spacing */
	   0,			/* 13 - IP address low */
	   0xf2,		/* 14 - IP address high */
	   0x48,		/* 15 - bits (includes promisc) */
	   0,			/* 16 - FC delay lsb */
	   0x40,		/* 17 - FC delay msb */
	   0xf2,		/* 18 - bits */
	   0x80,		/* 19 - bits */
	   0x3f,		/* 20 */
	   0x05			/* 21 */
	   }
};

void
ee_probe ( struct pci_dev *pci_info )
{
    if ( pci_info->vendor != EE_VENDOR )
	return;
    if ( pci_info->device != EE_DEVICE )
	return;

    if ( ee_soft.count ) {
	ee_soft.count++;
	return;
    }
    ee_soft.count = 1;
    ee_soft.memaddr = pci_info->base[0];
    ee_soft.ioaddr = (void *) ((unsigned long) pci_info->base[1] & ~3);
    ee_soft.iobase = ee_soft.ioaddr;
    ee_soft.irq = pci_info->irq;
    ee_soft.active = 0;
} 

/* should normally return on first test */
static inline void
wait_for_done ( int addr )
{
	int wait;

	for ( wait=100; wait--; )
	    if ( ! inb ( addr ) )
	    	return;
}

/* These 4 bits are the entire EEPROM interface */
#define	EE_CLOCK	0x01	/* serial clock */
#define	EE_CS		0x02	/* chip select */
#define	EE_DATA_W	0x04
#define	EE_DATA_R	0x08

static int
eeprom ( int cmd, int len )
{
    int eeaddr;
    unsigned int rv = 0;
    int data;

    eeaddr = (int) ee_soft.iobase + CSR_EEPROM;

    outw ( EE_CS, eeaddr );
    udelay ( 2 );
    outw ( EE_CS | EE_CLOCK, eeaddr );
    udelay ( 2 );

    while ( len-- ) {
	data = (cmd & (1<<len)) ? EE_DATA_W : 0;
	outw ( EE_CS | data, eeaddr );
	udelay ( 2 );
	outw ( EE_CS|EE_CLOCK | data, eeaddr );
	udelay ( 2 );
	data = (inw ( eeaddr ) & EE_DATA_R) ? 1 : 0;
	rv = (rv<<1) | data;
    }

    outw ( EE_CS, eeaddr );
    udelay ( 2 );
    outw ( 0, eeaddr );

    return rv;
}

#define EE_READ_CMD	6

void
ee_eeprom ( void )
{
    int v;
    int size;
    int read_cmd;
    int i;
    unsigned short sum;
    unsigned short val;

    v = eeprom ( EE_READ_CMD << 24, 28 ) & 0xffe0000;
    /*
    printf ( "eeprom gives: %08x\n", v );
    */
    if ( v == 0xffe0000 ) {
	size = 0x100;
    	read_cmd = EE_READ_CMD << 24;
    } else {
	size = 0x40;
    	read_cmd = EE_READ_CMD << 22;
    }

    sum = 0;
    for ( i=0; i<size; i++ ) {
	val = eeprom ( read_cmd | (i<<16), 28 );
	sum += val;
	if ( i < EEPROM_SIZE ) {
	    ee_soft.eeprom[i] = val;
	    /*
	    printf ( "%04x\n", ee_soft.eeprom[i] );
	    */
	}
    }

    printf ( "ether addr = " );
    for ( i=0; i<ETH_ADDR_SIZE; i++ ) {
	val = ee_soft.eeprom[i/2];
	if ( i & 1 )
	    val >>= 8;
	ee_soft.eaddr[i] = val & 0xff;
	printf ( "%02x", ee_soft.eaddr[i] );
	if ( i < ETH_ADDR_SIZE-1 )
	    printf ( ":" );
    }
    printf ( "\n" );

    if ( sum != 0xbaba )
	printf ( "bogus eeprom checksum = %04x\n", sum );
}

static void
ee_locate ( void )
{
    ee_soft.count = 0;
    pci_find_all ( 0, ee_probe );
    if ( ee_soft.count < 1 )
	return;

    printf ( "ee100 at %08x (IRQ %d)\n", ee_soft.iobase, ee_soft.irq );
    ee_eeprom ();
}

void
ee_setup ( void )
{
    int io;
    struct rfd *rfdp;
    struct tfd *tfdp;
    int options;
    int rx_mode, tx_mode;
    int rxdma, txdma;
    int rxfifo, txfifo;
    unsigned char *eap;
    int i;

    io = (int) ee_soft.iobase;
    /* do a full software reset */
    outl ( 0, io + CSR_PORT );
    udelay ( 10000 );

    /* set up statistics thingie */
    outl ( (int) &stats, io + CSR_PTR );
    outw ( CU_STATSADDR | INT_MASK, io + CSR_CMD );
    wait_for_done ( io + CSR_CMD );

    /* initialize RU base */
    outl ( 0, io + CSR_PTR );
    outw ( RU_BASE | INT_MASK, io + CSR_CMD );
    wait_for_done ( io + CSR_CMD );

    /* initialize CU base */
    outl ( 0, io + CSR_PTR );
    outw ( CU_BASE | INT_MASK, io + CSR_CMD );
    wait_for_done ( io + CSR_CMD );

    tfdp = &txfd;
    /* load a bunch of parameters */
    tfdp->command = CL_SETUP;
    tfdp->status = 0;
    tfdp->link = (int) &config_cmd;

    /* copy station address into chip */
    eap = (unsigned char *) &tfdp->buffer;
    for ( i=0; i<ETH_ADDR_SIZE; i++ )
    	eap[i] = ee_soft.eaddr[i];

#ifdef notdef
    options = 0x40;	/* 10mbps half duplex */
    options |= 0x20;	/* 100 mbps ? */
    options |= 0x10;	/* full duplex */
#endif
    options = 0;	/* autosense */

#ifdef notdef
    rx_mode = 3;	/* promiscuous */
    rx_mode = 1;	/* all multi */
#endif
    rx_mode = 0;

    txfifo = 8;		/* in 4 byte units 0-15 */
    rxfifo = 8;

    txdma = 0;		/* burst length 0-127 */
    rxdma = 0;

    config_cmd.command = CL_SUSPEND | CL_CONFIG;
    config_cmd.status = 0;
    config_cmd.link = (int) tfdp;

    config_cmd.stuff[1] = (txfifo << 4 ) | rxfifo;
    config_cmd.stuff[4] = rxdma;
    config_cmd.stuff[5] = txdma + 0x80;
    config_cmd.stuff[15] = (rx_mode & 2) ? 0x49 : 0x48;
    config_cmd.stuff[19] = (options & 0x10) ? 0xC0 : 0x80;
    config_cmd.stuff[21] = (rx_mode & 1) ? 0x0D : 0x05;

    /* Get the CU going */
    outl ( (int) tfdp, io + CSR_PTR );
    outw ( CU_START | INT_MASK, io + CSR_CMD );
    wait_for_done ( io + CSR_CMD );

    rx_buf = netbuf_alloc ();
    if ( ! rx_buf )
    	panic ("ee100 cannot get rcv buffer");
    if ( sizeof(struct rfd) > NETBUF_PREPAD )
    	panic ("ee100 needs more prepad");

    /* Things didn't seem to work right when there was a gap
     * between the rfd and the buffer itself, so we jam them
     * neatly and tightly together.
     */
    rx_buf->cptr = rx_buf->bptr + (NETBUF_PREPAD - sizeof(struct rfd));
    rfdp = (struct rfd *) rx_buf->cptr;

    rfdp->status   = 0x0001;
    rfdp->command  = 0;
    rfdp->link  = (int) rfdp;
    rfdp->buffer  = (int) rx_buf->eptr;
    rfdp->count  = 0;
    rfdp->size = ETHER_SIZE + 10;

    /* start the receiver */
    ee_start_rcv ( 1 );
}

static int isr_count = 0;
static int xmt_count = 0;
static int rcv_count = 0;
static int isr_status = 0;
static int bog_count = 0;

/* Start the receiver */
void
ee_start_rcv ( int allow_int )
{
    int io = (int) ee_soft.iobase;
    struct rfd *rfdp;
    int cmd;

#define RFD_LAST	0x8000	/* last RFD in RFA */
#define RFD_SUSP	0x4000	/* suspend after receiving */

    /* Get receiver going again */
    rfdp = (struct rfd *) rx_buf->cptr;

    rfdp->status = 0;
    rfdp->command = RFD_LAST | RFD_SUSP;

    outl ( (int) rfdp, io + CSR_PTR );

    cmd = RU_START;
    if ( ! allow_int )
	cmd |= INT_MASK;

    outw ( cmd, io + CSR_CMD );
    wait_for_done ( io + CSR_CMD );
}

/* Handle an interrupt.
 * the Status we see during a receive interrupt
 * (with the CU suspended) is 0x5048, which is:
 * CU suspended, RU no resources,
 * FR (frame received) and RNR (receiver not ready).
 * the Status outside of this routine while waiting
 * for a packet is 0x0050, which is:
 * CU suspended, RU ready.
 * During a Tx interrupt, we see:
 * 0x2050 which is:
 * CU suspended, RU ready, CU not active interrupt.
 */
void
ee_isr ( int dummy )
{
    int io = (int) ee_soft.iobase;
    struct rfd *rfdp;
    int status;
    int len;
    struct netbuf *nbp;

    isr_count++;

    /* Acknowledge the interrupt */
    status = inw ( io + CSR_STATUS );
    isr_status = status;
    outw ( status & 0xff00, io + CSR_STATUS );

    /* With the 82558 chip, I see a 0xA050 status,
     * but then find the rfd status still zero.
     */
    if ( status & INT_FR ) {
	rfdp = (struct rfd *) rx_buf->cptr;

	if ( rfdp->status ) {
	    len = rfdp->count & 0x3fff;

	    /* XXX - someday be much more clever and avoid this copy.
	     */
	    nbp = netbuf_alloc_i ();

	    if ( nbp ) {
		memcpy ( (char *) nbp->eptr, (char *) rx_buf->eptr, len );
		nbp->elen = len;

		/*
		printf ( "\n" );
		dump_b ( (char *)rx_buf, 8 );
		printf ( "\n" );
		dump_b ( (char *)rx_buf->eptr, 8 );
		*/

		net_rcv ( nbp );
	    }
	    	
	    rcv_count++;

	    ee_start_rcv ( 1 );
	} else {
	    bog_count++;
	}
    }

    /* may also get INT_CNA */
    if ( status & INT_CX) {
	ee_xmt_done ();
	xmt_count++;
    }
}

/* Bypass the first 32 vectors.
 * (used by processor hardware)
 */
#define IRQ_BASE_VEC	0x20

int
ee_init ( void )
{
    ee_locate ();
    if ( ee_soft.count < 1 ) {
	printf ( "Cannot find an Intel Ether Pro 100 of any kind\n" );
	return 0;
    }

#ifdef VXWORKS
    {
	int num = IRQ_BASE_VEC + ee_soft.irq;

	/*
	sysIntDisablePIC ( num )
	*/
	intConnect ( INUM_TO_IVEC(num), ee_isr, 0 );
	sysIntEnablePIC ( num );
    }
#else
    irq_hookup ( ee_soft.irq, ee_isr, 0 );
#endif

    /* be sure this "semaphore" is clear */
    ee_xmt_done ();

    ee_setup ();
    return 1;
}

static volatile int xmt_active = 0;

void
ee_xmt_done ( void )
{
    	xmt_active = 0;
}

/* send a packet.
 * CSR status immediately after sending is 0x0048
 * later transitions to 0x2048, command block
 * shows 0xA000 (Done and OK).
 * 0x0048 is CU suspended, RU no resources.
 * 0x2048 is CNA (CU not active), CU suspended, RU no resources
 */
void
ee_send ( struct netbuf *nbp )
{
    int io = (int) ee_soft.iobase;
    unsigned short status;
    unsigned short xstatus;
    struct tfd *tfdp;
    int i;

    /* XXX - spin here !!! yuk.
     */
    while ( xmt_active )
    	;

    xmt_active = 1;

    memcpy ( nbp->eptr->src, ee_soft.eaddr, ETH_ADDR_SIZE );

    tfdp = &txfd;
    tfdp->command = CL_INT | CL_SUSPEND | CL_TXF;
    tfdp->status = 0;
    tfdp->link = (int) tfdp;
    tfdp->count = 0x02208000;
    tfdp->buffer = (int) &tfdp->addr0;

    tfdp->addr0 = (int) nbp->eptr;
    tfdp->size0 = sizeof(struct eth_hdr);

    tfdp->addr1 = (int) nbp->iptr;
    tfdp->size1 = nbp->ilen;

    outl ( (int) tfdp, io + CSR_PTR );
    outw ( CU_START, io + CSR_CMD );
    wait_for_done ( io + CSR_CMD );

#ifdef notdef
    status = inw ( io + CSR_STATUS );
    udelay ( 10 );
    xstatus = inw ( io + CSR_STATUS );

    printf ( "Packet sent: %04x, %04x, %04x\n", status, xstatus, tfdp->status );
#endif

}

void
ee_dump ( char *buf, int count )
{
	int i;

	if ( count > 60 ) count = 60;

	for ( i=0; i<count; i++ ) {
	    if ( i == 30 )
	    	printf ( "\n" );
	    printf ( "%02x", buf[i] & 0xff );
	}
	printf ( "\n" );
}

void
ee_show ( void )
{
	int io = (int) ee_soft.iobase;
	int status;

	if ( ! io || ! ee_soft.active )
	    return;

	status = inw ( io + CSR_STATUS );
    	printf ( "ee100 status: %04x\n", status );

    	printf ( "ISR count: %d\n", isr_count );
    	printf ( "ISR status: %04x\n", isr_status );
    	printf ( "Receive count: %d\n", rcv_count );
    	printf ( "Bogus count: %d\n", bog_count );
    	printf ( "Transmit count: %d\n", xmt_count );
}

/* THE END */
